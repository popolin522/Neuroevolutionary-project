# -*- coding: utf-8 -*-
"""ActiveLearningCodeforSam.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18C-04C1dPiHHsS8QNC8udM6hC_UKapy4
"""

import numpy as np
import os
import shutil
import random
from sklearn.gaussian_process import GaussianProcessRegressor
from sklearn.gaussian_process.kernels import RBF
from scipy.integrate._ivp.radau import P
from scipy.stats import norm
import lammps
import multiprocessing
absolute_dir = '/expanse/lustre/projects/ddp381/pl201/nanorod/nanocube/neural_4_test/'
def PotentialEnergy(args):
    traject_num, temperature, index, gen_num, total_trajectory = args
    lmp = lammps.lammps(cmdargs=["-log", "none", "-screen", os.devnull,  "-nocite"])
    os.makedirs(absolute_dir+"a_"+str(traject_num+gen_num*total_trajectory*10),exist_ok=True)

    os.chdir(absolute_dir+"a_"+str(traject_num+gen_num*total_trajectory*10))
    make_input_file()
    lammpsString_init = generate_init_config(traject_num+gen_num*total_trajectory*10)

    lammpsString_run = """

    #----------------------------------------------------------#
    # simulation settings #
    #----------------------------------------------------------#
      units	lj
      atom_style	molecular 
      boundary	p p p
      dimension 2
      pair_style lj/cut 7.5 #must define pair_style before Pair Coeffs	
      read_data Scan""" + str(index) +""".data
      neighbor 2.0 bin
      neigh_modify every 1 delay 1 check yes
      neigh_modify exclude molecule/intra all
      pair_style lj/cut 7.5		
      pair_coeff * * 1.0 1.0 1.12
      pair_coeff 1 1 1.0 1.0 1.12
      pair_coeff 1 2 1.0 1.0 1.12
      pair_coeff 2 2 1.0 1.0 2.50
      pair_modify shift yes

      #thermo		100000
      #thermo_style	custom step etotal ke pe temp press

      timestep	0.01

      variable tempvalue equal """ + str(temperature)+ """
      variable thermofile     string  thermo_""" + str(index) +""".dat
      variable step	equal step
      variable temp	equal temp
      variable etot	equal etotal
      variable ke	equal ke
      variable pe	equal pe
      variable press	equal press
      compute PotentialEnergy all pe
      compute temperature_val all temp

      #Intialize velocity
      velocity all create ${tempvalue} 1530917 rot yes dist gaussian loop geom
      run 0 #Velocity is not scaled to 3.0. See lammps webpage regarding creating velocity for rigid bodies
      velocity all scale ${tempvalue}
      #fix		fix_print all print 100000 "${step} ${etot} ${ke} ${pe} ${temp} ${press}" file ${thermofile} screen no title "#1:step 2:etot 3:ke 4:pe 5:temp 6:press"
      #dump		1 all custom 10000 product_""" + str(index) +""".lammpstrj mol id type x y z fx fy fz

      #isotherm assembly

      fix 3 all rigid/nve/small molecule langevin ${tempvalue} ${tempvalue} 100.0 1530917
      fix 2 all enforce2d #2D simulation
      fix_modify 3 bodyforces early
      
      fix 4 all ave/time 1 1 1 c_PotentialEnergy c_temperature_val file results""" + str(index) +""".txt 
      run 10000 #1*10^5
      unfix 3
      unfix 2
      set group all z 0.0 #reset z coordinate to prevent z coordinate error propagation
      write_data Scan""" + str(index+1) +""".data
      #clear #never use it here because we still need to extract potential energy afterwards 
    """
    lmp.commands_string(lammpsString_init)
    lmp.commands_string(lammpsString_run)

    PotentialEnergy = lmp.numpy.extract_compute('PotentialEnergy',0,0)
    lmp.close() #clear lammps instance here. otherwise your memory will be screwed
    # print(CubeCubeEnergy)
    os.chdir("..")

    return PotentialEnergy

def assign_change(t, n_hidden, weights):
  w_ij = weights[0,:] #### weights
  b_j = weights[1,:]  #### biases
  S_j = np.tanh(w_ij*t+b_j)
  w_jk = weights[2,:]

  change_parameter = np.sum(np.multiply(S_j, w_jk)) / n_hidden
  return change_parameter/5  #### you can arrange it depending on how you want these values to change

def parent_weight_update(all_weights,opt_ind,parent_genom_num,n_hidden,input_node):
  parent_weight = np.zeros((3*parent_genom_num,n_hidden*len(input_node)))
  for i in range(parent_genom_num):
    opt_index_i = opt_ind[i]
    parent_weight[range(3*i,3*i+3),:] = all_weights[range(3*opt_index_i,3*opt_index_i+3),:]

  return parent_weight

def mutate_genom(parent_weight,trajectory_number,parent_genom_num,n_hidden,input_node):
  mutated_weights = np.zeros((3*trajectory_number,n_hidden*len(input_node)))

  for k in range(parent_genom_num):
    mutation_for_each_parent = int(trajectory_number/parent_genom_num)
    mutated_weights[range(3*mutation_for_each_parent*k,3*mutation_for_each_parent*k+3),:] = parent_weight[range(3*k,3*k+3),:]
    for m in range(mutation_for_each_parent-1):
      mutated_weights[range(3*mutation_for_each_parent*k+3+3*m,3*mutation_for_each_parent*k+6+3*m),:] = parent_weight[range(3*k,3*k+3),:]+np.random.normal(0, 0.2, size = (3,n_hidden*len(input_node)))

  return mutated_weights

def changeaftergenone(mutatedweight,input_node,trajectory_number,n_hidden,initial_temp):
   temparray = np.zeros((trajectory_number,len(input_node)))
   temparray[:,0] = initial_temp
   for i in range(trajectory_number):
      traj_weights = mutatedweight[range(3*i,3*i+3),:]
      for t in input_node:
         weights = traj_weights[:,int(n_hidden*t*len(input_node)):int(n_hidden*t*len(input_node))+n_hidden]
         change_parameter = assign_change(t, n_hidden, weights)

         if change_parameter+temparray[i,int(t*len(input_node))] < 0:
            change_parameter = -change_parameter

         if t != input_node[len(input_node)-1]:
            temparray[i,int(t*len(input_node))+1] = temparray[i,int(t*len(input_node))]+change_parameter

   return temparray

def weight_and_change(input_node,trajectory_number,n_hidden,initial_temp):
   all_weights = np.zeros((3*trajectory_number,n_hidden*len(input_node)))
   temparray = np.zeros((trajectory_number,len(input_node)))
   temparray[:,0] = initial_temp
   for i in range(trajectory_number):
      for t in input_node:
         w_ij = np.random.normal(0, 1, size = (1,n_hidden))
         b_j = np.random.normal(0, 1, size = (1,n_hidden))  #### biases
         w_jk = np.random.normal(0, 1, size = (1,n_hidden))
         weights = np.vstack((w_ij,b_j,w_jk))
         all_weights[range(3*i,3*i+3),int(n_hidden*t*len(input_node)):int(n_hidden*t*len(input_node))+n_hidden] = weights

         change_parameter = assign_change(t, n_hidden, weights)

         while change_parameter+temparray[i,int(t*len(input_node))] < 0:
            w_ij = np.random.normal(0, 1, size = (1,n_hidden))
            b_j = np.random.normal(0, 1, size = (1,n_hidden))  #### biases
            w_jk = np.random.normal(0, 1, size = (1,n_hidden))
            weights = np.vstack((w_ij,b_j,w_jk))
            all_weights[range(3*i,3*i+3),int(n_hidden*t*len(input_node)):int(n_hidden*t*len(input_node))+n_hidden] = weights
            change_parameter = assign_change(t, n_hidden, weights)

         if t != input_node[len(input_node)-1]:
            temparray[i,int(t*len(input_node))+1] = temparray[i,int(t*len(input_node))]+change_parameter

   return temparray, all_weights

def generate_init_config(trajectory_number):
   np.random.seed(4*trajectory_number)
   rd_seed_in_lmp = int(1000*np.random.rand())
   #print('rd seed is ')
   #print(rd_seed_in_lmp)
   # Given text lines
   lammpsString ='''
      #Initialization
      units	lj
      atom_style	molecular 
      boundary	p p p
      dimension 2
      read_data lammps.input
      neighbor 2.0 bin
      neigh_modify every 1 delay 1 check yes
      neigh_modify exclude molecule/intra all
      pair_style lj/cut 7.5		
      pair_coeff * * 1.0 1.0 1.12
      pair_coeff 1 1 1.0 1.0 1.12
      pair_coeff 1 2 1.0 1.0 1.12
      pair_coeff 2 2 1.0 1.0 1.12

      pair_modify shift yes


      velocity all set 0.0 0.0 0.0 units box 
      fix 1 all setforce 0.0 0.0 0.0
      min_style cg
      minimize 1.0e-8 1.0e-8 100000 100000 
      #dump		1 all custom 100 equlibration.lammpstrj mol id type x y z fx fy fz

      unfix 1 #This caused me a lot of troubles. Remember to unfix it
      replicate 20 20 1
      #undump 1
      #System setting
      thermo		10000
      thermo_style	custom step etotal ke pe temp press

      timestep	0.005
      variable inittemp         equal 1.0
      variable endtemp         equal 0.0
      variable thermofile     string  equil_thermo.dat
      variable step	equal step
      variable temp	equal temp
      variable etot	equal etotal
      variable ke	equal ke
      variable pe	equal pe
      variable press	equal press

      #dump		1 all custom 100 equlibration.lammpstrj mol id type x y z fx fy fz

      #fix		fix_print all print 10000 "${step} ${etot} ${ke} ${pe} ${temp} ${press}" file ${thermofile} screen no title "#1:step 2:etot 3:ke 4:pe 5:temp 6:press"

      #Intialize velocity
      velocity all create ${inittemp} ''' + str(rd_seed_in_lmp) + ''' rot yes dist gaussian loop geom
      run 0 #Velocity is not scaled to 3.0. See lammps webpage regarding creating velocity for rigid bodies
      velocity all scale ${inittemp} 

      #Operation
      ## Equilibration
      fix 3 all rigid/nve/small molecule langevin ${inittemp} ${inittemp} 100.0 ''' + str(rd_seed_in_lmp) + '''
      fix 2 all enforce2d #2D simulation
      fix_modify 3 bodyforces early

      run 10000
      unfix 3
      unfix 2

      #write_restart restart_equil.equil
      write_data Scan0.data
      clear
   '''
   return lammpsString

def make_input_file():
   '''
   currently generating input data file (topology and coordinates) of the one producing Kagome lattice
   '''
   text_lines = '''LAMMPS patchy particle input data file

   13 atoms
   3 atom types

   -2.82842712474619 2.82842712474619 xlo xhi
   -2.82842712474619 2.82842712474619 ylo yhi
   -0.5 0.5 zlo zhi


   Masses

   1  1
   2  1
   3  1

   Atoms

   1   1     1      -1.000000      1.000000       0.000000
   2   1     1      0.000000      1.000000       0.000000
   3   1     1      1.000000      1.000000       0.000000
   4   1     1      -1.000000      0.000000       0.000000
   5   1     3      0.000000      0.000000       0.000000
   6   1     1      1.000000      0.000000       0.000000
   7   1     1      -1.000000      -1.000000       0.000000
   8   1     1      0.000000      -1.000000       0.000000
   9   1     1      1.000000      -1.000000       0.000000
   10   1     2      -1.0 1.5 0.000000
   11   1     2      1.0 1.5 0.000000
   12   1     2      1.0 -1.5 0.000000
   13   1     2      -1.5 0.0 0.000000'''

   with open('lammps.input', 'w') as file:
      file.write(text_lines + '\n')
   return
# Set up the initial input data
initial_temp = 0.3
n_hidden = 1000
trajectory_number = 20
final_gen_num = 20 #final_gen_num needs to be larger than parent_genom_num
parent_genom_num = 5
input_node = np.linspace(0,31/32,32)  #### t/t0

previous_optimum_index = 1000000+trajectory_number

for gen_num in range(final_gen_num):
   if gen_num == 0:
      temparray, all_weights = weight_and_change(input_node,trajectory_number,n_hidden,initial_temp)
      temparray_repeated = np.repeat(temparray, repeats=10, axis=0)
      print("Temperature array = ", temparray)
      for index in range(len(input_node)):
         simulation_args = [(i,temparray_repeated[i,index],index,gen_num,trajectory_number) for i in range(10*trajectory_number)]
         pool = multiprocessing.Pool(processes=10*trajectory_number)
         results = pool.map(PotentialEnergy, simulation_args)
         pool.close()
         pool.join()
         num_blocks = trajectory_number
         results = np.array(results)
         results_blocks = results.reshape(num_blocks, 10)
         averages = np.mean(results_blocks, axis=1)
         print("Results = ", averages, " for index=", index, " and genetic number=", gen_num)
         scores = np.array(averages)

      opt_ind = np.argsort(scores)[range(parent_genom_num)] #### gives the indices of 5 most minimum energy trajectories
      parent_weight = parent_weight_update(all_weights,opt_ind,parent_genom_num,n_hidden,input_node)
      print("Optimum indices = ", opt_ind)

   else:
      mutatedweight = mutate_genom(parent_weight,trajectory_number,parent_genom_num,n_hidden,input_node)
      temparray = changeaftergenone(mutatedweight,input_node,trajectory_number,n_hidden,initial_temp)
      temparray_repeated = np.repeat(temparray, repeats=10, axis=0)
      print("Temperature array = ", temparray)
      for index in range(len(input_node)):
         simulation_args = [(i,temparray_repeated[i,index],index,gen_num,trajectory_number) for i in range(10*trajectory_number)]
         pool = multiprocessing.Pool(processes=10*trajectory_number)
         results = pool.map(PotentialEnergy, simulation_args)
         pool.close()
         pool.join()
         num_blocks = trajectory_number
         results = np.array(results)
         results_blocks = results.reshape(num_blocks, 10)
         averages = np.mean(results_blocks, axis=1)
         print("Results = ", averages, " for index=", index, " and genetic number=", gen_num)
         scores = np.array(averages)

      opt_ind = np.argsort(scores)[range(parent_genom_num)]
      parent_weight = parent_weight_update(mutatedweight,opt_ind,parent_genom_num,n_hidden,input_node)
      print("Optimum indices = ", opt_ind)
